def updateImageInManifest(serviceName, imageName, imageTag) {
    sh """
        sed 's|image: ${serviceName}:.*|image: ${imageName}:${serviceName}-${imageTag}|g' k8s/microservices.yaml > k8s/microservices-updated.yaml
    """
}

pipeline {
    agent any

    options {
        // Keep only last 5 builds
        buildDiscarder(logRotator(numToKeepStr: '3'))
        // Clean workspace before build
        skipDefaultCheckout(true)
    }

    parameters {
        string(name: 'NEXUS_IP', defaultValue: '35.174.104.227', description: 'Nexus server IP address')
        string(name: 'SONAR_IP', defaultValue: '52.91.189.5', description: 'SonarQube server IP address')
        string(name: 'DOCKER_TAG', defaultValue: 'latest', description: 'Docker image tag to deploy')
        string(name: 'GIT_BRANCH', defaultValue: 'k8s', description: 'Git branch to checkout')

        booleanParam(name: 'ENABLE_TESTS', defaultValue: false, description: 'Enable running tests')
        booleanParam(name: 'ENABLE_SONAR', defaultValue: false, description: 'Enable SonarQube analysis')
        booleanParam(name: 'ABORT_ON_QUALITY_GATE_FAILURE', defaultValue: false, description: 'Abort pipeline if Quality Gate fails')
        booleanParam(name: 'DEPLOY_TO_NEXUS', defaultValue: false, description: 'Deploy artifacts to Nexus')
        booleanParam(name: 'BUILD_DOCKER_IMAGES', defaultValue: true, description: 'Build and tag Docker images')
        booleanParam(name: 'PUSH_TO_DOCKER_REGISTRY', defaultValue: true, description: 'Push Docker images to registry')
        booleanParam(name: 'ENABLE_TRIVY_FS_SCAN', defaultValue: true, description: 'Enable file system security scan')
        booleanParam(name: 'ENABLE_TRIVY_IMAGE_SCAN', defaultValue: true, description: 'Enable image security scan')
        booleanParam(name: 'CLEANUP_IMAGES', defaultValue: true, description: 'Cleanup local images after push')
        booleanParam(name: 'DEPLOY_TO_K8S', defaultValue: true, description: 'Deploy to Kubernetes cluster')
    }

    tools {
        maven 'MAVEN_3_9'
        jdk 'JDK21'
    }

    environment {
        DOCKER_IMAGE_NAME = "ghergutmadalin/patient-managment"
        NEXUS_CREDENTIALS = 'nexus-credentials'
        DOCKER_HUB_CREDENTIALS = 'docker-hub-credentials'
        SONAR_SERVER = 'SONAR_QUBE_SERVER'
        KUBECONFIG = credentials('kubeconfig-credentials')

        NEXUS_URL = "http://${params.NEXUS_IP}:8081"
        SONAR_URL = "http://${params.SONAR_IP}:9000"
        K8S_DEPLOYMENT_TIMEOUT = '300s'
    }

    stages {
        stage('Clean Workspace') {
            steps {
                cleanWs()
            }
        }

        stage('Git Checkout') {
            steps {
                git branch: "${params.GIT_BRANCH}", url: 'https://github.com/Ghergutftw/Patient-Management.git'
            }
        }

        stage('Load Services') {
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    env.SERVICES = parentPom.modules.join(',')
                    echo "Services detected: ${parentPom.modules}"
                }
            }
        }

        stage('Build Services') {
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules
                    
                    services.each { service ->
                        dir(service) {
                            echo "Building service: ${service}"
                            sh 'mvn clean package -DskipTests'
                        }
                    }
                }
            }
        }
        

        stage('File System Check with trivy') {
            when { expression { params.ENABLE_TRIVY_FS_SCAN } }
            steps {
                sh 'trivy fs --format table -o trivy-fs-report.html .'
            }
        }

        stage('SonarQube Analysis') {
            when { expression { params.ENABLE_SONAR } }
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules
                    
                    services.each { service ->
                        dir(service) {
                            withSonarQubeEnv("${env.SONAR_SERVER}") {
                                sh """mvn sonar:sonar \\
                                    -Dsonar.projectKey=PatientManagement-${service} \\
                                    -Dsonar.host.url=${env.SONAR_URL} \\
                                    -Dsonar.sources=src/main/java
                                    """
                            }
                        }
                    }
                }
            }
        }

        stage('Quality Gate') {
            when { expression { params.ENABLE_SONAR } }
            steps {
                script {
                    try {
                        timeout(time: 10, unit: 'MINUTES') {
                            // Use the same SonarQube server URL as configured in the analysis
                            def qg = waitForQualityGate(abortPipeline: false)
                            if (qg.status != 'OK') {
                                echo "Quality Gate failed: ${qg.status}"
                                if (params.ABORT_ON_QUALITY_GATE_FAILURE) {
                                    error("Quality Gate failed")
                                } else {
                                    echo "Continuing pipeline despite Quality Gate failure (as per configuration)"
                                }
                            } else {
                                echo "Quality Gate passed successfully"
                            }
                        }
                    } catch (Exception e) {
                        echo "ERROR: Quality Gate check failed with error: ${e.getMessage()}"
                        echo "INFO: This might be due to SonarQube server connectivity issues"
                        echo "SonarQube Server URL: ${env.SONAR_URL}"
                        
                        if (params.ABORT_ON_QUALITY_GATE_FAILURE) {
                            error("Quality Gate check failed: ${e.getMessage()}")
                        } else {
                            echo "Continuing pipeline despite Quality Gate error (as per configuration)"
                        }
                    }
                }
            }
        }

        stage('Deploy to Nexus') {
            when { expression { params.DEPLOY_TO_NEXUS } }
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules

                    services.each { service ->
                        def pom = readMavenPom file: "${service}/pom.xml"
                        
                        // Keep original SNAPSHOT version - Nexus will handle timestamping
                        def version = pom.version
                        def artifactFile = "${service}/target/${pom.artifactId}-${pom.version}.jar"

                        nexusArtifactUploader(
                            nexusVersion: 'nexus3',
                            protocol: 'http',
                            nexusUrl: "${params.NEXUS_IP}:8081",
                            groupId: pom.groupId,
                            version: version, // Use original version
                            repository: 'maven-snapshots',
                            credentialsId: "${env.NEXUS_CREDENTIALS}",
                            artifacts: [
                                [
                                    artifactId: pom.artifactId,
                                    classifier: '',
                                    file: artifactFile,
                                    type: 'jar'
                                ]
                            ]
                        )
                    }
                }
            }
        }

        stage('Build and Tag Docker Images') {
            when { expression { params.BUILD_DOCKER_IMAGES } }
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules

                    services.each { service ->
                        dir(service) {
                            echo "Building Docker image for ${service}..."

                            // Build Docker image using Spring Boot build-image
                            sh "mvn spring-boot:build-image -Dspring-boot.build-image.imageName=${service}:${params.DOCKER_TAG} -DskipTests"

                            // Tag the image with registry name
                            sh "docker tag ${service}:${params.DOCKER_TAG} ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}"

                            // Verify the image was tagged correctly
                            sh "docker images | grep ${env.DOCKER_IMAGE_NAME}"

                            echo "Successfully built and tagged ${service}"
                        }
                    }
                }
            }
        }

        stage('Docker Image Security Scan with Trivy') {
            when { 
                allOf {
                    expression { params.ENABLE_TRIVY_IMAGE_SCAN }
                    expression { params.BUILD_DOCKER_IMAGES }
                }
            }
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules

                    services.each { service ->
                        echo "Scanning image: ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}"

                        // Verify image exists before scanning
                        sh """
                            if docker inspect ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG} > /dev/null 2>&1; then
                                echo "Image found, starting Trivy scan..."
                                trivy image --format table -o trivy-${service}-image-report.html ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}
                                echo "Trivy scan completed for ${service}"
                            else
                                echo "Image ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG} not found"
                                echo "Available images:"
                                docker images | grep patient-managment || echo "No patient-managment images found"
                                exit 1
                            fi
                        """
                    }
                }
            }
        }

        stage('Push to Docker Registry') {
            when { expression { params.PUSH_TO_DOCKER_REGISTRY } }
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules

                    withDockerRegistry([credentialsId: "${env.DOCKER_HUB_CREDENTIALS}", url: 'https://index.docker.io/v1/']) {
                        services.each { service ->
                            echo "Pushing image: ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}"

                            def image = docker.image("${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}")
                            image.push()

                            // Also push with latest tag
                            image.push("${service}-latest")

                            echo "Successfully pushed ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}"
                        }
                    }
                }
            }
        }

        stage('Cleanup Local Images') {
            when { 
                allOf {
                    expression { params.CLEANUP_IMAGES }
                    expression { params.BUILD_DOCKER_IMAGES }
                }
            }
            steps {
                script {
                    def parentPom = readMavenPom file: 'pom.xml'
                    def services = parentPom.modules

                    echo "Cleaning up local images to save space..."
                    services.each { service ->
                        // Remove the local build images to save space
                        sh "docker rmi ${service}:${params.DOCKER_TAG} || true"
                        sh "docker rmi ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG} || true"
                    }

                    // Clean up dangling images
                    sh "docker system prune -f || true"
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when { expression { params.DEPLOY_TO_K8S } }
            steps {
                script {
                    echo "Deploying to Kubernetes cluster..."
                    
                    // Update image tags in microservices manifest
                    def services = ['patient-service', 'billing-service', 'auth-service', 'analytics-service', 'api-gateway']
                    
                    sh "cp k8s/microservices.yaml k8s/microservices-updated.yaml"
                    
                    services.each { service ->
                        sh """
                            sed -i 's|image: ${service}:.*|image: ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}|g' k8s/microservices-updated.yaml
                        """
                        echo "Updated ${service} image to ${env.DOCKER_IMAGE_NAME}:${service}-${params.DOCKER_TAG}"
                    }
                    
                    // Deploy in correct order: namespace -> config -> infrastructure -> services
                    echo "Deploying namespace and configuration..."
                    sh "kubectl apply -f k8s/patient-management-namespace.yaml"
                    sh "kubectl apply -f k8s/postgres-configmap.yaml"
                    
                    echo "Deploying infrastructure components..."
                    sh "kubectl apply -f k8s/infrastructure.yaml"
                    
                    echo "Deploying microservices..."
                    sh "kubectl apply -f k8s/microservices-updated.yaml"
                    
                    // Wait for deployments to be ready
                    echo "Waiting for deployments to be ready..."
                    services.each { service ->
                        sh "kubectl rollout status deployment/${service} -n patient-management --timeout=${env.K8S_DEPLOYMENT_TIMEOUT}"
                    }
                    
                    echo "Deployment completed successfully"
                }
            }
            post {
                failure {
                    script {
                        echo "Deployment failed, attempting rollback..."
                        def services = ['api-gateway', 'analytics-service', 'billing-service', 'patient-service', 'auth-service']
                        services.each { service ->
                            sh "kubectl rollout undo deployment/${service} -n patient-management || echo 'Cannot rollback ${service}'"
                        }
                    }
                }
            }
        }

        stage('Verify Kubernetes Deployment') {
            when { expression { params.DEPLOY_TO_K8S } }
            steps {
                script {
                    echo "Verifying Kubernetes deployment..."
                    
                    sh "kubectl get pods -n patient-management"
                    sh "kubectl get services -n patient-management"
                    
                    echo "=============================================="
                    echo "DEPLOYMENT SUMMARY"
                    echo "=============================================="
                    echo "Namespace: patient-management"
                    echo "Docker Images Tag: ${params.DOCKER_TAG}"
                    echo "API Gateway URL: Check LoadBalancer service or use port-forward"
                    echo "Grafana Dashboard: admin/admin credentials"
                    echo "=============================================="
                    
                    echo "Deployment verification completed"
                }
            }
        }
    }

    post {
        always {
            script {
                // Only run junit if test results exist
                if (fileExists('**/target/surefire-reports/*.xml')) {
                    junit '**/target/surefire-reports/*.xml'
                }

                // Archive artifacts if they exist
                if (fileExists('**/target/*.jar')) {
                    archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true
                }

                // Publish Trivy reports if they exist // needs HTML Publisher
                if (fileExists('trivy-fs-report.html')) {
                    publishHTML([
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: '.',
                        reportFiles: 'trivy-fs-report.html',
                        reportName: 'Trivy File System Report'
                    ])
                }

                // Publish individual Docker image reports
                def parentPom = readMavenPom file: 'pom.xml'
                def services = parentPom.modules
                services.each { service ->
                    def reportFile = "trivy-${service}-image-report.html"
                    if (fileExists(reportFile)) {
                        publishHTML([
                            allowMissing: false,
                            alwaysLinkToLastBuild: true,
                            keepAll: true,
                            reportDir: '.',
                            reportFiles: reportFile,
                            reportName: "Trivy ${service.capitalize()} Image Report"
                        ])
                    }
                }

            }

            cleanup {
                script {
                    sh '''
                    df -h
                        # Clean Docker resources
                        docker system prune -a -f
                        docker volume prune -f
                        docker builder prune -a -f

                        # Clean Maven cache (if running on Jenkins agent)
                        rm -rf ~/.m2/repository/*

                        # Clean temporary files
                        sudo rm -rf /tmp/*
                    '''

                }
    
            }
        }

        failure {
            script {
                echo "Pipeline failed. Debugging information:"
                sh '''
                    echo "=== All Docker Images ==="
                    docker images

                    echo "=== Patient Management Images ==="
                    docker images | grep patient-managment || echo "No patient-managment images found"

                    echo "=== Docker System Info ==="
                    docker system df || true

                    echo "=== Available Disk Space ==="
                    df -h || true
                '''
                
                if (params.DEPLOY_TO_K8S) {
                    sh """
                        echo "=== Kubernetes Debug Info ==="
                        kubectl get all -n patient-management || true
                        kubectl describe pods -n patient-management || true
                    """
                }
            }
        }

        success {
            script {
                echo "Pipeline completed successfully!"
                echo "Check the Trivy reports for security scan results"
                echo "Images pushed to: https://hub.docker.com/repository/docker/ghergutmadalin/patient-managment"
                
                if (params.DEPLOY_TO_K8S) {
                    echo "Application deployed to Kubernetes namespace: patient-management"
                    echo "Access your application through the LoadBalancer services"
                }
            }
        }
    }

}